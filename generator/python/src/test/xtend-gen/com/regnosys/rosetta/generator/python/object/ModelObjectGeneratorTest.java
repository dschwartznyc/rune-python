package com.regnosys.rosetta.generator.python.object;

import com.google.inject.Inject;
import com.regnosys.rosetta.generator.python.PythonCodeGenerator;
import com.regnosys.rosetta.rosetta.RosettaModel;
import com.regnosys.rosetta.tests.RosettaInjectorProvider;
import com.regnosys.rosetta.tests.util.ModelHelper;
import java.util.Collections;
import java.util.HashMap;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.extensions.InjectionExtension;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(InjectionExtension.class)
@InjectWith(RosettaInjectorProvider.class)
@SuppressWarnings("all")
public class ModelObjectGeneratorTest {
  @Inject
  @Extension
  private ModelHelper _modelHelper;

  @Inject
  private PythonCodeGenerator generator;

  @Test
  public void testGenerateBasicTypeString() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type Tester:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("one string (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("list string (0..*)");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class Tester(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("one: Optional[str] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("list: List[str] = Field([], description=\"\")");
    _builder_1.newLine();
    _builder_1.newLine();
    final String expected = _builder_1.toString();
    Assertions.assertTrue(python.toString().contains(expected));
  }

  @Test
  public void testGenerateBasicTypeInt() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type Tester:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("one int (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("list int (0..*)");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class Tester(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("one: Optional[int] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("list: List[int] = Field([], description=\"\")");
    _builder_1.newLine();
    _builder_1.newLine();
    final String expected = _builder_1.toString();
    Assertions.assertTrue(python.toString().contains(expected));
  }

  @Test
  public void testGenerateBasicTypeNumber() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type Tester:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("one number (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("list number (0..*)");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class Tester(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("one: Optional[Decimal] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("list: List[Decimal] = Field([], description=\"\")");
    _builder_1.newLine();
    _builder_1.newLine();
    final String expected = _builder_1.toString();
    Assertions.assertTrue(python.toString().contains(expected));
  }

  @Test
  public void testGenerateBasicTypeBoolean() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type Tester:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("one boolean (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("list boolean (0..*)");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class Tester(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("one: Optional[bool] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("list: List[bool] = Field([], description=\"\")");
    _builder_1.newLine();
    final String expected = _builder_1.toString();
    Assertions.assertTrue(python.toString().contains(expected));
  }

  @Test
  public void testGenerateBasicTypeDate() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type Tester:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("one date (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("list date (0..*)");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class Tester(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("one: Optional[datetime.date] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("list: List[datetime.date] = Field([], description=\"\")");
    _builder_1.newLine();
    _builder_1.newLine();
    final String expected = _builder_1.toString();
    Assertions.assertTrue(python.toString().contains(expected));
  }

  @Test
  public void testGenerateBasicTypeDateTime() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type Tester:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("one date (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("list date (0..*)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("zoned zonedDateTime (0..1)");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class Tester(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("one: Optional[datetime.date] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("list: List[datetime.date] = Field([], description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("zoned: Optional[datetime.datetime] = Field(None, description=\"\")");
    _builder_1.newLine();
    final String expected = _builder_1.toString();
    Assertions.assertTrue(python.toString().contains(expected));
  }

  @Test
  public void testGenerateBasicTypeTime() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type Tester:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("one time (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("list time (0..*)");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class Tester(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("one: Optional[datetime.time] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("list: List[datetime.time] = Field([], description=\"\")");
    _builder_1.newLine();
    _builder_1.newLine();
    final String expected = _builder_1.toString();
    Assertions.assertTrue(python.toString().contains(expected));
  }

  @Test
  @Disabled
  public void testGenerateMetaFieldWhenAttributeSchemePresent() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type TestObject: <\"\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("fieldOne string (0..1) [metadata scheme]");
    _builder.newLine();
    this.generatePython(_builder);
  }

  @Test
  @Disabled
  public void testGenerateRosettaReferenceField() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type TestObject: <\"\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("fieldOne Test2 (0..1) [metadata reference]");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type Test2:");
    _builder.newLine();
    this.generatePython(_builder);
  }

  @Test
  @Disabled
  public void testGenerateBasicReferenceField() {
    final String namespace = "test.ns.basicref";
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("namespace \"");
    _builder.append(namespace);
    _builder.append("\"");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("// import basic types");
    _builder.newLine();
    _builder.append("import com.rosetta.test.model.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type TestObject: <\"\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("fieldOne date (0..1) [metadata reference]");
    _builder.newLine();
    this.generatePython(_builder);
  }

  @Test
  @Disabled
  public void testCreateFieldWithReferenceTypeWhenAttributeIsReference() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    _builder.append("type ComplexObject:");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type TestObject: <\"\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("fieldOne ComplexObject (0..1) [metadata reference]");
    _builder.newLine();
    this.generatePython(_builder);
  }

  @Test
  @Disabled
  public void testGenerateTypeWithMetaFieldImport() {
    final String namespace = "test.ns.metafield";
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("namespace \"");
    _builder.append(namespace);
    _builder.append("\"");
    _builder.newLineIfNotEmpty();
    _builder.append("version \"test\"");
    _builder.newLine();
    _builder.newLine();
    _builder.append("// import basic types");
    _builder.newLine();
    _builder.append("import com.rosetta.test.model.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type Foo:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("[metadata key]");
    _builder.newLine();
    _builder.append("    ");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("attr string (0..1)");
    _builder.newLine();
    this.generatePython(_builder);
  }

  @Test
  @Disabled
  public void testImplementGlobalKeyWhenDefined() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type WithGlobalKey:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("[metadata key]");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("bar string (1..1)");
    _builder.newLine();
    this.generatePython(_builder);
  }

  @Test
  public void testOmitGlobalKeyAnnotationWhenNotDefined() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type AttributeGlobalKeyTest:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("withoutGlobalKey string (1..1)");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class AttributeGlobalKeyTest(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("withoutGlobalKey: str = Field(..., description=\"\")");
    _builder_1.newLine();
    _builder_1.newLine();
    final String expected = _builder_1.toString();
    Assertions.assertTrue(python.toString().contains(expected));
  }

  @Test
  @Disabled
  public void testGenerateReferenceAttributeAsReference() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type Foo:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("[metadata key]");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("bar string (1..1)");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type AttributeGlobalKeyTest:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("withGlobalKey Foo (1..1) [metadata reference]");
    _builder.newLine();
    this.generatePython(_builder);
  }

  @Test
  public void testGenerateClassList() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type A extends B:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("c C (1..*)");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type B:");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type C :");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("one int (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("list int (0..*)");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("type D:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("s string (1..*)");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class B(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("pass");
    _builder_1.newLine();
    final String expectedB = _builder_1.toString();
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("class C(BaseDataClass):");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("one: Optional[int] = Field(None, description=\"\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("list: List[int] = Field([], description=\"\")");
    _builder_2.newLine();
    _builder_2.newLine();
    final String expectedC = _builder_2.toString();
    StringConcatenation _builder_3 = new StringConcatenation();
    _builder_3.append("class A(B):");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("c: List[com.rosetta.test.model.C.C] = Field([], description=\"\")");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("@rosetta_condition");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("def cardinality_c(self):");
    _builder_3.newLine();
    _builder_3.append("        ");
    _builder_3.append("return check_cardinality(self.c, 1, None)");
    _builder_3.newLine();
    final String expectedA = _builder_3.toString();
    StringConcatenation _builder_4 = new StringConcatenation();
    _builder_4.append("class D(BaseDataClass):");
    _builder_4.newLine();
    _builder_4.append("    ");
    _builder_4.append("s: List[str] = Field([], description=\"\")");
    _builder_4.newLine();
    _builder_4.append("    ");
    _builder_4.append("@rosetta_condition");
    _builder_4.newLine();
    _builder_4.append("    ");
    _builder_4.append("def cardinality_s(self):");
    _builder_4.newLine();
    _builder_4.append("        ");
    _builder_4.append("return check_cardinality(self.s, 1, None)");
    _builder_4.newLine();
    final String expectedD = _builder_4.toString();
    Assertions.assertTrue(python.toString().contains(expectedA));
    Assertions.assertTrue(python.toString().contains(expectedB));
    Assertions.assertTrue(python.toString().contains(expectedC));
    Assertions.assertTrue(python.toString().contains(expectedD));
  }

  @Test
  public void testExtendATypeWithSameAttribute() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type Foo:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("a string (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("b string (0..1)");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type Bar extends Foo:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("a string (0..1)");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class Foo(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("a: Optional[str] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("b: Optional[str] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.newLine();
    final String expectedFoo = _builder_1.toString();
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("class Bar(Foo):");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("a: Optional[str] = Field(None, description=\"\")");
    _builder_2.newLine();
    _builder_2.newLine();
    final String expectedBar = _builder_2.toString();
    Assertions.assertTrue(python.toString().contains(expectedFoo));
    Assertions.assertTrue(python.toString().contains(expectedBar));
  }

  @Test
  public void testGenerateRosettaCalculationTypeAsString() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type Foo:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("bar calculation (0..1)");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class Foo(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("bar: Optional[str] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.newLine();
    final String expected = _builder_1.toString();
    Assertions.assertTrue(python.toString().contains(expected));
  }

  @Test
  public void testSetAttributesOnEmptyClassWithInheritance() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type Foo:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("attr string (0..1)");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type Bar extends Foo:");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class Foo(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("attr: Optional[str] = Field(None, description=\"\")");
    _builder_1.newLine();
    final String expectedFoo = _builder_1.toString();
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("class Bar(Foo):");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("pass");
    _builder_2.newLine();
    final String expectedBar = _builder_2.toString();
    Assertions.assertTrue(python.toString().contains(expectedFoo));
    Assertions.assertTrue(python.toString().contains(expectedBar));
  }

  @Test
  @Disabled
  public void isProductWithEnumValueRef() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("isProduct root Foo;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("enum Enum: ");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("A");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("B");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type Foo:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("attr Enum (0..1)");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func Qualify_FooProd:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("[qualification Product]");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: is_product boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set is_product:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("foo -> attr = Enum -> A");
    _builder.newLine();
    this.generatePython(_builder);
  }

  @Test
  @Disabled
  public void internalReferenceTest() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    _builder.append("type Foo:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("foo string (1..1)");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("[metadata location]");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type Bar:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("bar string (1..1)");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("[metadata address \"pointsTo\"=Foo->foo]");
    _builder.newLine();
    _builder.newLine();
    this.generatePython(_builder);
  }

  @Test
  public void testConditions1() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type A:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("a0 int (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("a1 int (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("condition: one-of");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type B:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("intValue1 int (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("intValue2 int (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("aValue A (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("condition Rule:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("intValue1 < 100");
    _builder.newLine();
    _builder.append("    ");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("condition OneOrTwo: <\"Choice rule to represent an FpML choice construct.\">");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("optional choice intValue1, intValue2");
    _builder.newLine();
    _builder.append("    ");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("condition SecondOneOrTwo: <\"FpML specifies a choice between adjustedDate and [unadjustedDate (required), dateAdjutsments (required), adjustedDate (optional)].\">");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("aValue->a0 exists");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("or (intValue2 exists and intValue1 exists and intValue1 exists)");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("or (intValue2 exists and intValue1 exists and intValue1 is absent)");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class A(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("a0: Optional[int] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("a1: Optional[int] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("@rosetta_condition");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("def condition_0_(self):");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("item = self");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("return self.check_one_of_constraint(\'a0\', \'a1\', necessity=True)");
    final String expectedA = _builder_1.toString();
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("class B(BaseDataClass):");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("intValue1: Optional[int] = Field(None, description=\"\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("intValue2: Optional[int] = Field(None, description=\"\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("aValue: com.rosetta.test.model.A.A = Field(..., description=\"\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("@rosetta_condition");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("def condition_0_Rule(self):");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("item = self");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("return all_elements(rosetta_resolve_attr(self, \"intValue1\"), \"<\", 100)");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("@rosetta_condition");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("def condition_1_OneOrTwo(self):");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("Choice rule to represent an FpML choice construct.");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("item = self");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("return self.check_one_of_constraint(\'intValue1\', \'intValue2\', necessity=False)");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("@rosetta_condition");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("def condition_2_SecondOneOrTwo(self):");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("FpML specifies a choice between adjustedDate and [unadjustedDate (required), dateAdjutsments (required), adjustedDate (optional)].");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("item = self");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("return ((rosetta_attr_exists(rosetta_resolve_attr(rosetta_resolve_attr(self, \"aValue\"), \"a0\")) or ((rosetta_attr_exists(rosetta_resolve_attr(self, \"intValue2\")) and rosetta_attr_exists(rosetta_resolve_attr(self, \"intValue1\"))) and rosetta_attr_exists(rosetta_resolve_attr(self, \"intValue1\")))) or ((rosetta_attr_exists(rosetta_resolve_attr(self, \"intValue2\")) and rosetta_attr_exists(rosetta_resolve_attr(self, \"intValue1\"))) and (not rosetta_attr_exists(rosetta_resolve_attr(self, \"intValue1\")))))");
    final String expectedB = _builder_2.toString();
    Assertions.assertTrue(python.toString().contains(expectedA));
    Assertions.assertTrue(python.toString().contains(expectedB));
  }

  @Test
  public void testGenerateTypes() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type TestType: <\"Test type description.\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("testTypeValue1 string (1..1) <\"Test string\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("testTypeValue2 string (0..1) <\"Test optional string\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("testTypeValue3 string (0..*) <\"Test string list\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("testTypeValue4 TestType2 (1..1) <\"Test TestType2\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("testEnum TestEnum (0..1) <\"Optional test enum\">");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type TestType2:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("testType2Value1 number(1..*) <\"Test number list\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("testType2Value2 date(0..1) <\"Test date\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("testEnum TestEnum (0..1) <\"Optional test enum\">");
    _builder.newLine();
    _builder.newLine();
    _builder.append("enum TestEnum: <\"Test enum description.\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("TestEnumValue1 <\"Test enum value 1\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("TestEnumValue2 <\"Test enum value 2\">");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class TestType(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test type description.");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("testTypeValue1: str = Field(..., description=\"Test string\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test string");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("testTypeValue2: Optional[str] = Field(None, description=\"Test optional string\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test optional string");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("testTypeValue3: List[str] = Field([], description=\"Test string list\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test string list");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("testTypeValue4: com.rosetta.test.model.TestType2.TestType2 = Field(..., description=\"Test TestType2\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test TestType2");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("testEnum: Optional[com.rosetta.test.model.TestEnum.TestEnum] = Field(None, description=\"Optional test enum\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Optional test enum");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    final String expectedTestType = _builder_1.toString();
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("class TestType2(BaseDataClass):");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("testType2Value1: List[Decimal] = Field([], description=\"Test number list\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("Test number list");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("@rosetta_condition");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("def cardinality_testType2Value1(self):");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("return check_cardinality(self.testType2Value1, 1, None)");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("testType2Value2: Optional[datetime.date] = Field(None, description=\"Test date\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("Test date");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("testEnum: Optional[com.rosetta.test.model.TestEnum.TestEnum] = Field(None, description=\"Optional test enum\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("Optional test enum");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    final String expectedTestType2 = _builder_2.toString();
    Assertions.assertTrue(python.toString().contains(expectedTestType));
    Assertions.assertTrue(python.toString().contains(expectedTestType2));
  }

  @Test
  public void testGenerateTypesMethod2() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type UnitType: <\"Defines the unit to be used for price, quantity, or other purposes\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("currency string (0..1) <\"Defines the currency to be used as a unit for a price, quantity, or other purpose.\">");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type MeasureBase: <\"Provides an abstract base class shared by Price and Quantity.\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("amount number (1..1) <\"Specifies an amount to be qualified and used in a Price or Quantity definition.\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("unitOfAmount UnitType (1..1) <\"Qualifies the unit by which the amount is measured.\">");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type Quantity extends MeasureBase: <\"Specifies a quantity to be associated to a financial product, for example a trade amount or a cashflow amount resulting from a trade.\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("multiplier number (0..1) <\"Defines the number to be multiplied by the amount to derive a total quantity.\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("multiplierUnit UnitType (0..1) <\"Qualifies the multiplier with the applicable unit.  For example in the case of the Coal (API2) CIF ARA (ARGUS-McCloskey) Futures Contract on the CME, where the unitOfAmount would be contracts, the multiplier would 1,000 and the mulitiplier Unit would be 1,000 MT (Metric Tons).\">");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class MeasureBase(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Provides an abstract base class shared by Price and Quantity.");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("amount: Decimal = Field(..., description=\"Specifies an amount to be qualified and used in a Price or Quantity definition.\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Specifies an amount to be qualified and used in a Price or Quantity definition.");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("unitOfAmount: com.rosetta.test.model.UnitType.UnitType = Field(..., description=\"Qualifies the unit by which the amount is measured.\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Qualifies the unit by which the amount is measured.");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    final String expectedMeasureBase = _builder_1.toString();
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("class UnitType(BaseDataClass):");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("Defines the unit to be used for price, quantity, or other purposes");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("currency: Optional[str] = Field(None, description=\"Defines the currency to be used as a unit for a price, quantity, or other purpose.\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("Defines the currency to be used as a unit for a price, quantity, or other purpose.");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    final String expectedUnitType = _builder_2.toString();
    StringConcatenation _builder_3 = new StringConcatenation();
    _builder_3.append("class Quantity(MeasureBase):");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("\"\"\"");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("Specifies a quantity to be associated to a financial product, for example a trade amount or a cashflow amount resulting from a trade.");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("\"\"\"");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("multiplier: Optional[Decimal] = Field(None, description=\"Defines the number to be multiplied by the amount to derive a total quantity.\")");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("\"\"\"");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("Defines the number to be multiplied by the amount to derive a total quantity.");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("\"\"\"");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("multiplierUnit: Optional[com.rosetta.test.model.UnitType.UnitType] = Field(None, description=\"Qualifies the multiplier with the applicable unit. For example in the case of the Coal (API2) CIF ARA (ARGUS-McCloskey) Futures Contract on the CME, where the unitOfAmount would be contracts, the multiplier would 1,000 and the mulitiplier Unit would be 1,000 MT (Metric Tons).\")");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("\"\"\"");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("Qualifies the multiplier with the applicable unit.  For example in the case of the Coal (API2) CIF ARA (ARGUS-McCloskey) Futures Contract on the CME, where the unitOfAmount would be contracts, the multiplier would 1,000 and the mulitiplier Unit would be 1,000 MT (Metric Tons).");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("\"\"\"");
    final String expectedQuantity = _builder_3.toString();
    Assertions.assertTrue(python.toString().contains(expectedMeasureBase));
    Assertions.assertTrue(python.toString().contains(expectedUnitType));
    Assertions.assertTrue(python.toString().contains(expectedQuantity));
  }

  @Test
  public void testGenerateTypesExtends() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type TestType extends TestType2:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("TestTypeValue1 string (1..1) <\"Test string\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("TestTypeValue2 int (0..1) <\"Test int\">");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type TestType2 extends TestType3:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("TestType2Value1 number (0..1) <\"Test number\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("TestType2Value2 date (0..*) <\"Test date\">");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type TestType3:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("TestType3Value1 string (0..1) <\"Test string\">");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("TestType4Value2 int (1..*) <\"Test int\">");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class TestType(TestType2):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("TestTypeValue1: str = Field(..., description=\"Test string\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test string");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("TestTypeValue2: Optional[int] = Field(None, description=\"Test int\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test int");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    final String expectedTestType = _builder_1.toString();
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("class TestType2(TestType3):");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("TestType2Value1: Optional[Decimal] = Field(None, description=\"Test number\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("Test number");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("TestType2Value2: List[datetime.date] = Field([], description=\"Test date\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("Test date");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("\"\"\"");
    final String expectedTestType2 = _builder_2.toString();
    StringConcatenation _builder_3 = new StringConcatenation();
    _builder_3.append("class TestType3(BaseDataClass):");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("TestType3Value1: Optional[str] = Field(None, description=\"Test string\")");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("\"\"\"");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("Test string");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("\"\"\"");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("TestType4Value2: List[int] = Field([], description=\"Test int\")");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("\"\"\"");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("Test int");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("\"\"\"");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("@rosetta_condition");
    _builder_3.newLine();
    _builder_3.append("    ");
    _builder_3.append("def cardinality_TestType4Value2(self):");
    _builder_3.newLine();
    _builder_3.append("        ");
    _builder_3.append("return check_cardinality(self.TestType4Value2, 1, None)");
    final String expectedTestType3 = _builder_3.toString();
    Assertions.assertTrue(python.toString().contains(expectedTestType));
    Assertions.assertTrue(python.toString().contains(expectedTestType2));
    Assertions.assertTrue(python.toString().contains(expectedTestType3));
  }

  @Test
  public void testGenerateTypesChoiceCondition() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type TestType: <\"Test type with one-of condition.\">");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("field1 string (0..1) <\"Test string field 1\">");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("field2 string (0..1) <\"Test string field 2\">");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("field3 number (0..1) <\"Test number field 3\">");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("field4 number (0..*) <\"Test number field 4\">");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("condition BusinessCentersChoice: <\"Choice rule to represent an FpML choice construct.\">");
    _builder.newLine();
    _builder.append("                    ");
    _builder.append("required choice field1, field2");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    final String types = python.toString();
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class TestType(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test type with one-of condition.");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("field1: Optional[str] = Field(None, description=\"Test string field 1\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test string field 1");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("field2: Optional[str] = Field(None, description=\"Test string field 2\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test string field 2");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("field3: Optional[Decimal] = Field(None, description=\"Test number field 3\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test number field 3");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("field4: List[Decimal] = Field([], description=\"Test number field 4\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test number field 4");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("@rosetta_condition");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("def condition_0_BusinessCentersChoice(self):");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("Choice rule to represent an FpML choice construct.");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("item = self");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("return self.check_one_of_constraint(\'field1\', \'field2\', necessity=True)");
    final String expected = _builder_1.toString();
    Assertions.assertTrue(types.contains(expected));
  }

  @Test
  public void testGenerateIfThenCondition() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type TestType: <\"Test type with one-of condition.\">");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("field1 string (0..1) <\"Test string field 1\">");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("field2 string (0..1) <\"Test string field 2\">");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("field3 number (0..1) <\"Test number field 3\">");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("field4 number (0..*) <\"Test number field 4\">");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("condition BusinessCentersChoice: <\"Choice rule to represent an FpML choice construct.\">");
    _builder.newLine();
    _builder.append("                    ");
    _builder.append("if field1 exists");
    _builder.newLine();
    _builder.append("                            ");
    _builder.append("then field3 > 0");
    _builder.newLine();
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class TestType(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test type with one-of condition.");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("field1: Optional[str] = Field(None, description=\"Test string field 1\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test string field 1");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("field2: Optional[str] = Field(None, description=\"Test string field 2\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test string field 2");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("field3: Optional[Decimal] = Field(None, description=\"Test number field 3\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test number field 3");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("field4: List[Decimal] = Field([], description=\"Test number field 4\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("Test number field 4");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("@rosetta_condition");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("def condition_0_BusinessCentersChoice(self):");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("Choice rule to represent an FpML choice construct.");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("\"\"\"");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("item = self");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("def _then_fn0():");
    _builder_1.newLine();
    _builder_1.append("            ");
    _builder_1.append("return all_elements(rosetta_resolve_attr(self, \"field3\"), \">\", 0)");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("def _else_fn0():");
    _builder_1.newLine();
    _builder_1.append("            ");
    _builder_1.append("return True");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("return if_cond_fn(rosetta_attr_exists(rosetta_resolve_attr(self, \"field1\")), _then_fn0, _else_fn0)");
    final String expected = _builder_1.toString();
    Assertions.assertTrue(python.toString().contains(expected));
  }

  @Test
  public void testConditionsGeneration() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type A:");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("a0 int (0..1)");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("a1 int (0..1)");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("condition: one-of");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("type B:");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("intValue1 int (0..1)");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("intValue2 int (0..1)");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("aValue A (1..1)");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("condition Rule:");
    _builder.newLine();
    _builder.append("                ");
    _builder.append("intValue1 < 100");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("condition OneOrTwo: <\"Choice rule to represent an FpML choice construct.\">");
    _builder.newLine();
    _builder.append("                ");
    _builder.append("optional choice intValue1, intValue2");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("condition ReqOneOrTwo: <\"Choice rule to represent an FpML choice construct.\">");
    _builder.newLine();
    _builder.append("                ");
    _builder.append("required choice intValue1, intValue2");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("condition SecondOneOrTwo: <\"FpML specifies a choice between adjustedDate and [unadjustedDate (required), dateAdjutsments (required), adjustedDate (optional)].\">");
    _builder.newLine();
    _builder.append("                ");
    _builder.append("aValue->a0 exists");
    _builder.newLine();
    _builder.append("                    ");
    _builder.append("or (intValue2 exists and intValue1 exists and intValue1 exists)");
    _builder.newLine();
    _builder.append("                    ");
    _builder.append("or (intValue2 exists and intValue1 exists and intValue1 is absent)");
    final HashMap<String, CharSequence> python = this.generatePython(_builder);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("class A(BaseDataClass):");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("a0: Optional[int] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("a1: Optional[int] = Field(None, description=\"\")");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("@rosetta_condition");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("def condition_0_(self):");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("item = self");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("return self.check_one_of_constraint(\'a0\', \'a1\', necessity=True)");
    final String expectedA = _builder_1.toString();
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("class B(BaseDataClass):");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("intValue1: Optional[int] = Field(None, description=\"\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("intValue2: Optional[int] = Field(None, description=\"\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("aValue: com.rosetta.test.model.A.A = Field(..., description=\"\")");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("@rosetta_condition");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("def condition_0_Rule(self):");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("item = self");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("return all_elements(rosetta_resolve_attr(self, \"intValue1\"), \"<\", 100)");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("@rosetta_condition");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("def condition_1_OneOrTwo(self):");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("Choice rule to represent an FpML choice construct.");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("item = self");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("return self.check_one_of_constraint(\'intValue1\', \'intValue2\', necessity=False)");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("@rosetta_condition");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("def condition_2_ReqOneOrTwo(self):");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("Choice rule to represent an FpML choice construct.");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("item = self");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("return self.check_one_of_constraint(\'intValue1\', \'intValue2\', necessity=True)");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("@rosetta_condition");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("def condition_3_SecondOneOrTwo(self):");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("FpML specifies a choice between adjustedDate and [unadjustedDate (required), dateAdjutsments (required), adjustedDate (optional)].");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("\"\"\"");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("item = self");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("return ((rosetta_attr_exists(rosetta_resolve_attr(rosetta_resolve_attr(self, \"aValue\"), \"a0\")) or ((rosetta_attr_exists(rosetta_resolve_attr(self, \"intValue2\")) and rosetta_attr_exists(rosetta_resolve_attr(self, \"intValue1\"))) and rosetta_attr_exists(rosetta_resolve_attr(self, \"intValue1\")))) or ((rosetta_attr_exists(rosetta_resolve_attr(self, \"intValue2\")) and rosetta_attr_exists(rosetta_resolve_attr(self, \"intValue1\"))) and (not rosetta_attr_exists(rosetta_resolve_attr(self, \"intValue1\")))))");
    final String expectedB = _builder_2.toString();
    Assertions.assertTrue(python.toString().contains(expectedA));
    Assertions.assertTrue(python.toString().contains(expectedB));
  }

  public HashMap<String, CharSequence> generatePython(final CharSequence model) {
    HashMap<String, CharSequence> _xblockexpression = null;
    {
      final RosettaModel m = this._modelHelper.parseRosettaWithNoErrors(model);
      final ResourceSet resourceSet = m.eResource().getResourceSet();
      final String version = m.getVersion();
      final HashMap<String, CharSequence> result = CollectionLiterals.<String, CharSequence>newHashMap();
      result.putAll(this.generator.beforeAllGenerate(resourceSet, Collections.<RosettaModel>unmodifiableSet(CollectionLiterals.<RosettaModel>newHashSet(m)), version));
      result.putAll(this.generator.beforeGenerate(m.eResource(), m, version));
      result.putAll(this.generator.generate(m.eResource(), m, version));
      result.putAll(this.generator.afterGenerate(m.eResource(), m, version));
      result.putAll(this.generator.afterAllGenerate(resourceSet, Collections.<RosettaModel>unmodifiableSet(CollectionLiterals.<RosettaModel>newHashSet(m)), version));
      _xblockexpression = result;
    }
    return _xblockexpression;
  }
}
