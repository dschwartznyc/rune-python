package com.regnosys.rosetta.generator.python.expression;

import com.google.inject.Inject;
import com.regnosys.rosetta.generator.python.PythonCodeGenerator;
import com.regnosys.rosetta.rosetta.RosettaModel;
import com.regnosys.rosetta.tests.RosettaInjectorProvider;
import com.regnosys.rosetta.tests.util.ModelHelper;
import java.util.Collections;
import java.util.HashMap;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.extensions.InjectionExtension;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(InjectionExtension.class)
@InjectWith(RosettaInjectorProvider.class)
@SuppressWarnings("all")
public class RosettaExistsExpressionTest {
  @Inject
  @Extension
  private ModelHelper _modelHelper;

  @Inject
  private PythonCodeGenerator generator;

  @Test
  public void setUp() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("type Foo:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("bar Bar (0..*)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("baz Baz (0..1)");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type Bar:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("before number (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("after number (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("other number (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("beforeWithScheme number (0..1)");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("[metadata scheme]");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("afterWithScheme number (0..1)");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("[metadata scheme]");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("beforeList number (0..*)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("afterList number (0..*)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("beforeListWithScheme number (0..*)");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("[metadata scheme]");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("afterListWithScheme number (0..*)");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("[metadata scheme]");
    _builder.newLine();
    _builder.newLine();
    _builder.append("type Baz:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("bazValue number (0..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("other number (0..1)");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func Exists:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("foo -> bar -> before exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func SingleExists:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("foo -> bar -> before single exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func MultipleExists:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("foo -> bar -> before multiple exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func OnlyExists:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("foo -> bar -> before only exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func OnlyExistsMultiplePaths:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("( foo -> bar -> before, foo -> bar -> after ) only exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func OnlyExistsPathWithScheme:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("( foo -> bar -> before, foo -> bar -> afterWithScheme ) only exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func OnlyExistsBothPathsWithScheme:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("( foo -> bar -> beforeWithScheme, foo -> bar -> afterWithScheme ) only exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func OnlyExistsListMultiplePaths:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("( foo -> bar -> before, foo -> bar -> afterList ) only exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func OnlyExistsListPathWithScheme:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("( foo -> bar -> before, foo -> bar -> afterListWithScheme ) only exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func OnlyExistsListBothPathsWithScheme:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("( foo -> bar -> beforeListWithScheme, foo -> bar -> afterListWithScheme ) only exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func MultipleSeparateOr_NoAliases_Exists:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("foo -> bar -> before exists or foo -> bar -> after exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func MultipleOr_NoAliases_Exists:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("foo -> bar -> before exists or foo -> bar -> after exists or foo -> baz -> other exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func MultipleOrBranchNode_NoAliases_Exists:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("foo -> bar exists or foo -> baz exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func MultipleAnd_NoAliases_Exists:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("foo -> bar -> before exists and foo -> bar -> after exists and foo -> baz -> other exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func MultipleOrAnd_NoAliases_Exists:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("foo -> bar -> before exists or ( foo -> bar -> after exists and foo -> baz -> other exists )");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func MultipleOrAnd_NoAliases_Exists2:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("(foo -> bar -> before exists and foo -> bar -> after exists) or foo -> baz -> other exists or foo -> baz -> bazValue exists");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func MultipleOrAnd_NoAliases_Exists3:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("(foo -> bar -> before exists or foo -> bar -> after exists) or (foo -> baz -> other exists and foo -> baz -> bazValue exists)");
    _builder.newLine();
    _builder.newLine();
    _builder.append("func MultipleExistsWithOrAnd:");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("inputs: foo Foo (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("output: result boolean (1..1)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("set result:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("foo -> bar -> before exists or ( foo -> baz -> other exists and foo -> bar -> after exists ) or foo -> baz -> bazValue exists");
    _builder.newLine();
    this.generatePython(_builder);
  }

  public HashMap<String, CharSequence> generatePython(final CharSequence model) {
    HashMap<String, CharSequence> _xblockexpression = null;
    {
      final RosettaModel m = this._modelHelper.parseRosettaWithNoErrors(model);
      final ResourceSet resourceSet = m.eResource().getResourceSet();
      final String version = m.getVersion();
      final HashMap<String, CharSequence> result = CollectionLiterals.<String, CharSequence>newHashMap();
      result.putAll(this.generator.beforeAllGenerate(resourceSet, Collections.<RosettaModel>unmodifiableSet(CollectionLiterals.<RosettaModel>newHashSet(m)), version));
      result.putAll(this.generator.beforeGenerate(m.eResource(), m, version));
      result.putAll(this.generator.generate(m.eResource(), m, version));
      result.putAll(this.generator.afterGenerate(m.eResource(), m, version));
      result.putAll(this.generator.afterAllGenerate(resourceSet, Collections.<RosettaModel>unmodifiableSet(CollectionLiterals.<RosettaModel>newHashSet(m)), version));
      _xblockexpression = result;
    }
    return _xblockexpression;
  }
}
